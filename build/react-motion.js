(function(global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined'
    ? factory(exports, require('react'))
    : typeof define === 'function' && define.amd
      ? define(['exports', 'react'], factory)
      : factory((global.ReactMotion = {}), global.React);
})(this, function(exports, React) {
  'use strict';

  React = React && React.hasOwnProperty('default') ? React['default'] : React;

  function _extends() {
    _extends =
      Object.assign ||
      function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      };

    return _extends.apply(this, arguments);
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }

  // currently used to initiate the velocity style object to 0
  function mapToZero(obj) {
    var ret = {};

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        ret[key] = 0;
      }
    }

    return ret;
  }

  // turn {x: {val: 1, stiffness: 1, damping: 2}, y: 2} generated by
  // `{x: spring(1, {stiffness: 1, damping: 2}), y: 2}` into {x: 1, y: 2}
  function stripStyle(style) {
    var ret = {};

    for (var key in style) {
      if (!Object.prototype.hasOwnProperty.call(style, key)) {
        continue;
      }

      ret[key] = typeof style[key] === 'number' ? style[key] : style[key].val;
    }

    return ret;
  }

  // stepper is used a lot. Saves allocation to return the same array wrapper.
  // This is fine and danger-free against mutations because the callsite
  // immediately destructures it and gets the numbers inside without passing the
  // array reference around.
  var reusedTuple = [0, 0];
  function stepper(secondPerFrame, x, v, destX, k, b, precision) {
    // Spring stiffness, in kg / s^2
    // for animations, destX is really spring length (spring at rest). initial
    // position is considered as the stretched/compressed position of a spring
    var Fspring = -k * (x - destX); // Damping, in kg / s

    var Fdamper = -b * v; // usually we put mass here, but for animation purposes, specifying mass is a
    // bit redundant. you could simply adjust k and b accordingly
    // let a = (Fspring + Fdamper) / mass;

    var a = Fspring + Fdamper;
    var newV = v + a * secondPerFrame;
    var newX = x + newV * secondPerFrame;

    if (Math.abs(newV) < precision && Math.abs(newX - destX) < precision) {
      reusedTuple[0] = destX;
      reusedTuple[1] = 0;
      return reusedTuple;
    }

    reusedTuple[0] = newX;
    reusedTuple[1] = newV;
    return reusedTuple;
  }

  var commonjsGlobal =
    typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
        ? global
        : typeof self !== 'undefined'
          ? self
          : {};

  function createCommonjsModule(fn, module) {
    return (
      (module = { exports: {} }), fn(module, module.exports), module.exports
    );
  }

  var performanceNow = createCommonjsModule(function(module) {
    // Generated by CoffeeScript 1.12.2
    (function() {
      var getNanoSeconds,
        hrtime,
        loadTime,
        moduleLoadTime,
        nodeLoadTime,
        upTime;

      if (
        typeof performance !== 'undefined' &&
        performance !== null &&
        performance.now
      ) {
        module.exports = function() {
          return performance.now();
        };
      } else if (
        typeof process !== 'undefined' &&
        process !== null &&
        process.hrtime
      ) {
        module.exports = function() {
          return (getNanoSeconds() - nodeLoadTime) / 1e6;
        };
        hrtime = process.hrtime;
        getNanoSeconds = function() {
          var hr;
          hr = hrtime();
          return hr[0] * 1e9 + hr[1];
        };
        moduleLoadTime = getNanoSeconds();
        upTime = process.uptime() * 1e9;
        nodeLoadTime = moduleLoadTime - upTime;
      } else if (Date.now) {
        module.exports = function() {
          return Date.now() - loadTime;
        };
        loadTime = Date.now();
      } else {
        module.exports = function() {
          return new Date().getTime() - loadTime;
        };
        loadTime = new Date().getTime();
      }
    }.call(commonjsGlobal));
  });

  var root = typeof window === 'undefined' ? commonjsGlobal : window,
    vendors = ['moz', 'webkit'],
    suffix = 'AnimationFrame',
    raf = root['request' + suffix],
    caf = root['cancel' + suffix] || root['cancelRequest' + suffix];

  for (var i = 0; !raf && i < vendors.length; i++) {
    raf = root[vendors[i] + 'Request' + suffix];
    caf =
      root[vendors[i] + 'Cancel' + suffix] ||
      root[vendors[i] + 'CancelRequest' + suffix];
  }

  // Some versions of FF have rAF but not cAF
  if (!raf || !caf) {
    var last = 0,
      id = 0,
      queue = [],
      frameDuration = 1000 / 60;

    raf = function(callback) {
      if (queue.length === 0) {
        var _now = performanceNow(),
          next = Math.max(0, frameDuration - (_now - last));
        last = next + _now;
        setTimeout(function() {
          var cp = queue.slice(0);
          // Clear queue here to prevent
          // callbacks from appending listeners
          // to the current frame's queue
          queue.length = 0;
          for (var i = 0; i < cp.length; i++) {
            if (!cp[i].cancelled) {
              try {
                cp[i].callback(last);
              } catch (e) {
                setTimeout(function() {
                  throw e;
                }, 0);
              }
            }
          }
        }, Math.round(next));
      }
      queue.push({
        handle: ++id,
        callback: callback,
        cancelled: false,
      });
      return id;
    };

    caf = function(handle) {
      for (var i = 0; i < queue.length; i++) {
        if (queue[i].handle === handle) {
          queue[i].cancelled = true;
        }
      }
    };
  }

  var raf_1 = function(fn) {
    // Wrap in a new function to prevent
    // `cancel` potentially being assigned
    // to the native rAF function
    return raf.call(root, fn);
  };
  var cancel = function() {
    caf.apply(root, arguments);
  };
  var polyfill = function(object) {
    if (!object) {
      object = root;
    }
    object.requestAnimationFrame = raf;
    object.cancelAnimationFrame = caf;
  };
  raf_1.cancel = cancel;
  raf_1.polyfill = polyfill;

  // usage assumption: currentStyle values have already been rendered but it says
  // nothing of whether currentStyle is stale (see unreadPropStyle)
  function shouldStopAnimation(currentStyle, style, currentVelocity) {
    for (var key in style) {
      if (!Object.prototype.hasOwnProperty.call(style, key)) {
        continue;
      }

      if (currentVelocity[key] !== 0) {
        return false;
      }

      var styleValue =
        typeof style[key] === 'number' ? style[key] : style[key].val; // stepper will have already taken care of rounding precision errors, so
      // won't have such thing as 0.9999 !=== 1

      if (currentStyle[key] !== styleValue) {
        return false;
      }
    }

    return true;
  }

  /*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  */
  /* eslint-disable no-unused-vars */
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;

  function toObject(val) {
    if (val === null || val === undefined) {
      throw new TypeError(
        'Object.assign cannot be called with null or undefined',
      );
    }

    return Object(val);
  }

  function shouldUseNative() {
    try {
      if (!Object.assign) {
        return false;
      }

      // Detect buggy property enumeration order in older V8 versions.

      // https://bugs.chromium.org/p/v8/issues/detail?id=4118
      var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
      test1[5] = 'de';
      if (Object.getOwnPropertyNames(test1)[0] === '5') {
        return false;
      }

      // https://bugs.chromium.org/p/v8/issues/detail?id=3056
      var test2 = {};
      for (var i = 0; i < 10; i++) {
        test2['_' + String.fromCharCode(i)] = i;
      }
      var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
        return test2[n];
      });
      if (order2.join('') !== '0123456789') {
        return false;
      }

      // https://bugs.chromium.org/p/v8/issues/detail?id=3056
      var test3 = {};
      'abcdefghijklmnopqrst'.split('').forEach(function(letter) {
        test3[letter] = letter;
      });
      if (
        Object.keys(Object.assign({}, test3)).join('') !==
        'abcdefghijklmnopqrst'
      ) {
        return false;
      }

      return true;
    } catch (err) {
      // We don't expect any of the above to throw, but better to be safe.
      return false;
    }
  }

  var objectAssign = shouldUseNative()
    ? Object.assign
    : function(target, source) {
        var from;
        var to = toObject(target);
        var symbols;

        for (var s = 1; s < arguments.length; s++) {
          from = Object(arguments[s]);

          for (var key in from) {
            if (hasOwnProperty.call(from, key)) {
              to[key] = from[key];
            }
          }

          if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);
            for (var i = 0; i < symbols.length; i++) {
              if (propIsEnumerable.call(from, symbols[i])) {
                to[symbols[i]] = from[symbols[i]];
              }
            }
          }
        }

        return to;
      };

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

  var ReactPropTypesSecret_1 = ReactPropTypesSecret;

  var printWarning = function() {};

  {
    var ReactPropTypesSecret$1 = ReactPropTypesSecret_1;
    var loggedTypeFailures = {};

    printWarning = function(text) {
      var message = 'Warning: ' + text;
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch (x) {}
    };
  }

  /**
   * Assert that the values match with the type specs.
   * Error messages are memorized and will only be shown once.
   *
   * @param {object} typeSpecs Map of name to a ReactPropType
   * @param {object} values Runtime values that need to be type-checked
   * @param {string} location e.g. "prop", "context", "child context"
   * @param {string} componentName Name of the component for error messages.
   * @param {?Function} getStack Returns the component stack.
   * @private
   */
  function checkPropTypes(
    typeSpecs,
    values,
    location,
    componentName,
    getStack,
  ) {
    {
      for (var typeSpecName in typeSpecs) {
        if (typeSpecs.hasOwnProperty(typeSpecName)) {
          var error;
          // Prop type validation may throw. In case they do, we don't want to
          // fail the render phase where it didn't fail before. So we log it.
          // After these have been cleaned up, we'll let them throw.
          try {
            // This is intentionally an invariant that gets caught. It's the same
            // behavior as without this statement except with a better message.
            if (typeof typeSpecs[typeSpecName] !== 'function') {
              var err = Error(
                (componentName || 'React class') +
                  ': ' +
                  location +
                  ' type `' +
                  typeSpecName +
                  '` is invalid; ' +
                  'it must be a function, usually from the `prop-types` package, but received `' +
                  typeof typeSpecs[typeSpecName] +
                  '`.',
              );
              err.name = 'Invariant Violation';
              throw err;
            }
            error = typeSpecs[typeSpecName](
              values,
              typeSpecName,
              componentName,
              location,
              null,
              ReactPropTypesSecret$1,
            );
          } catch (ex) {
            error = ex;
          }
          if (error && !(error instanceof Error)) {
            printWarning(
              (componentName || 'React class') +
                ': type specification of ' +
                location +
                ' `' +
                typeSpecName +
                '` is invalid; the type checker ' +
                'function must return `null` or an `Error` but returned a ' +
                typeof error +
                '. ' +
                'You may have forgotten to pass an argument to the type checker ' +
                'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
                'shape all require an argument).',
            );
          }
          if (
            error instanceof Error &&
            !(error.message in loggedTypeFailures)
          ) {
            // Only monitor this failure once because there tends to be a lot of the
            // same error.
            loggedTypeFailures[error.message] = true;

            var stack = getStack ? getStack() : '';

            printWarning(
              'Failed ' +
                location +
                ' type: ' +
                error.message +
                (stack != null ? stack : ''),
            );
          }
        }
      }
    }
  }

  var checkPropTypes_1 = checkPropTypes;

  var printWarning$1 = function() {};

  {
    printWarning$1 = function(text) {
      var message = 'Warning: ' + text;
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch (x) {}
    };
  }

  function emptyFunctionThatReturnsNull() {
    return null;
  }

  var factoryWithTypeCheckers = function(isValidElement, throwOnDirectAccess) {
    /* global Symbol */
    var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

    /**
     * Returns the iterator method function contained on the iterable object.
     *
     * Be sure to invoke the function with the iterable as context:
     *
     *     var iteratorFn = getIteratorFn(myIterable);
     *     if (iteratorFn) {
     *       var iterator = iteratorFn.call(myIterable);
     *       ...
     *     }
     *
     * @param {?object} maybeIterable
     * @return {?function}
     */
    function getIteratorFn(maybeIterable) {
      var iteratorFn =
        maybeIterable &&
        ((ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL]) ||
          maybeIterable[FAUX_ITERATOR_SYMBOL]);
      if (typeof iteratorFn === 'function') {
        return iteratorFn;
      }
    }

    /**
     * Collection of methods that allow declaration and validation of props that are
     * supplied to React components. Example usage:
     *
     *   var Props = require('ReactPropTypes');
     *   var MyArticle = React.createClass({
     *     propTypes: {
     *       // An optional string prop named "description".
     *       description: Props.string,
     *
     *       // A required enum prop named "category".
     *       category: Props.oneOf(['News','Photos']).isRequired,
     *
     *       // A prop named "dialog" that requires an instance of Dialog.
     *       dialog: Props.instanceOf(Dialog).isRequired
     *     },
     *     render: function() { ... }
     *   });
     *
     * A more formal specification of how these methods are used:
     *
     *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
     *   decl := ReactPropTypes.{type}(.isRequired)?
     *
     * Each and every declaration produces a function with the same signature. This
     * allows the creation of custom validation functions. For example:
     *
     *  var MyLink = React.createClass({
     *    propTypes: {
     *      // An optional string or URI prop named "href".
     *      href: function(props, propName, componentName) {
     *        var propValue = props[propName];
     *        if (propValue != null && typeof propValue !== 'string' &&
     *            !(propValue instanceof URI)) {
     *          return new Error(
     *            'Expected a string or an URI for ' + propName + ' in ' +
     *            componentName
     *          );
     *        }
     *      }
     *    },
     *    render: function() {...}
     *  });
     *
     * @internal
     */

    var ANONYMOUS = '<<anonymous>>';

    // Important!
    // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
    var ReactPropTypes = {
      array: createPrimitiveTypeChecker('array'),
      bool: createPrimitiveTypeChecker('boolean'),
      func: createPrimitiveTypeChecker('function'),
      number: createPrimitiveTypeChecker('number'),
      object: createPrimitiveTypeChecker('object'),
      string: createPrimitiveTypeChecker('string'),
      symbol: createPrimitiveTypeChecker('symbol'),

      any: createAnyTypeChecker(),
      arrayOf: createArrayOfTypeChecker,
      element: createElementTypeChecker(),
      instanceOf: createInstanceTypeChecker,
      node: createNodeChecker(),
      objectOf: createObjectOfTypeChecker,
      oneOf: createEnumTypeChecker,
      oneOfType: createUnionTypeChecker,
      shape: createShapeTypeChecker,
      exact: createStrictShapeTypeChecker,
    };

    /**
     * inlined Object.is polyfill to avoid requiring consumers ship their own
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
     */
    /*eslint-disable no-self-compare*/
    function is(x, y) {
      // SameValue algorithm
      if (x === y) {
        // Steps 1-5, 7-10
        // Steps 6.b-6.e: +0 != -0
        return x !== 0 || 1 / x === 1 / y;
      } else {
        // Step 6.a: NaN == NaN
        return x !== x && y !== y;
      }
    }
    /*eslint-enable no-self-compare*/

    /**
     * We use an Error-like object for backward compatibility as people may call
     * PropTypes directly and inspect their output. However, we don't use real
     * Errors anymore. We don't inspect their stack anyway, and creating them
     * is prohibitively expensive if they are created too often, such as what
     * happens in oneOfType() for any type before the one that matched.
     */
    function PropTypeError(message) {
      this.message = message;
      this.stack = '';
    }
    // Make `instanceof Error` still work for returned errors.
    PropTypeError.prototype = Error.prototype;

    function createChainableTypeChecker(validate) {
      {
        var manualPropTypeCallCache = {};
        var manualPropTypeWarningCount = 0;
      }
      function checkType(
        isRequired,
        props,
        propName,
        componentName,
        location,
        propFullName,
        secret,
      ) {
        componentName = componentName || ANONYMOUS;
        propFullName = propFullName || propName;

        if (secret !== ReactPropTypesSecret_1) {
          if (throwOnDirectAccess) {
            // New behavior only for users of `prop-types` package
            var err = new Error(
              'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
                'Use `PropTypes.checkPropTypes()` to call them. ' +
                'Read more at http://fb.me/use-check-prop-types',
            );
            err.name = 'Invariant Violation';
            throw err;
          } else if (typeof console !== 'undefined') {
            // Old behavior for people using React.PropTypes
            var cacheKey = componentName + ':' + propName;
            if (
              !manualPropTypeCallCache[cacheKey] &&
              // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3
            ) {
              printWarning$1(
                'You are manually calling a React.PropTypes validation ' +
                  'function for the `' +
                  propFullName +
                  '` prop on `' +
                  componentName +
                  '`. This is deprecated ' +
                  'and will throw in the standalone `prop-types` package. ' +
                  'You may be seeing this warning due to a third-party PropTypes ' +
                  'library. See https://fb.me/react-warning-dont-call-proptypes ' +
                  'for details.',
              );
              manualPropTypeCallCache[cacheKey] = true;
              manualPropTypeWarningCount++;
            }
          }
        }
        if (props[propName] == null) {
          if (isRequired) {
            if (props[propName] === null) {
              return new PropTypeError(
                'The ' +
                  location +
                  ' `' +
                  propFullName +
                  '` is marked as required ' +
                  ('in `' + componentName + '`, but its value is `null`.'),
              );
            }
            return new PropTypeError(
              'The ' +
                location +
                ' `' +
                propFullName +
                '` is marked as required in ' +
                ('`' + componentName + '`, but its value is `undefined`.'),
            );
          }
          return null;
        } else {
          return validate(
            props,
            propName,
            componentName,
            location,
            propFullName,
          );
        }
      }

      var chainedCheckType = checkType.bind(null, false);
      chainedCheckType.isRequired = checkType.bind(null, true);

      return chainedCheckType;
    }

    function createPrimitiveTypeChecker(expectedType) {
      function validate(
        props,
        propName,
        componentName,
        location,
        propFullName,
        secret,
      ) {
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== expectedType) {
          // `propValue` being instance of, say, date/regexp, pass the 'object'
          // check, but we can offer a more precise error message here rather than
          // 'of type `object`'.
          var preciseType = getPreciseType(propValue);

          return new PropTypeError(
            'Invalid ' +
              location +
              ' `' +
              propFullName +
              '` of type ' +
              ('`' +
                preciseType +
                '` supplied to `' +
                componentName +
                '`, expected ') +
              ('`' + expectedType + '`.'),
          );
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }

    function createAnyTypeChecker() {
      return createChainableTypeChecker(emptyFunctionThatReturnsNull);
    }

    function createArrayOfTypeChecker(typeChecker) {
      function validate(
        props,
        propName,
        componentName,
        location,
        propFullName,
      ) {
        if (typeof typeChecker !== 'function') {
          return new PropTypeError(
            'Property `' +
              propFullName +
              '` of component `' +
              componentName +
              '` has invalid PropType notation inside arrayOf.',
          );
        }
        var propValue = props[propName];
        if (!Array.isArray(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError(
            'Invalid ' +
              location +
              ' `' +
              propFullName +
              '` of type ' +
              ('`' +
                propType +
                '` supplied to `' +
                componentName +
                '`, expected an array.'),
          );
        }
        for (var i = 0; i < propValue.length; i++) {
          var error = typeChecker(
            propValue,
            i,
            componentName,
            location,
            propFullName + '[' + i + ']',
            ReactPropTypesSecret_1,
          );
          if (error instanceof Error) {
            return error;
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }

    function createElementTypeChecker() {
      function validate(
        props,
        propName,
        componentName,
        location,
        propFullName,
      ) {
        var propValue = props[propName];
        if (!isValidElement(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError(
            'Invalid ' +
              location +
              ' `' +
              propFullName +
              '` of type ' +
              ('`' +
                propType +
                '` supplied to `' +
                componentName +
                '`, expected a single ReactElement.'),
          );
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }

    function createInstanceTypeChecker(expectedClass) {
      function validate(
        props,
        propName,
        componentName,
        location,
        propFullName,
      ) {
        if (!(props[propName] instanceof expectedClass)) {
          var expectedClassName = expectedClass.name || ANONYMOUS;
          var actualClassName = getClassName(props[propName]);
          return new PropTypeError(
            'Invalid ' +
              location +
              ' `' +
              propFullName +
              '` of type ' +
              ('`' +
                actualClassName +
                '` supplied to `' +
                componentName +
                '`, expected ') +
              ('instance of `' + expectedClassName + '`.'),
          );
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }

    function createEnumTypeChecker(expectedValues) {
      if (!Array.isArray(expectedValues)) {
        printWarning$1(
          'Invalid argument supplied to oneOf, expected an instance of array.',
        );
        return emptyFunctionThatReturnsNull;
      }

      function validate(
        props,
        propName,
        componentName,
        location,
        propFullName,
      ) {
        var propValue = props[propName];
        for (var i = 0; i < expectedValues.length; i++) {
          if (is(propValue, expectedValues[i])) {
            return null;
          }
        }

        var valuesString = JSON.stringify(expectedValues);
        return new PropTypeError(
          'Invalid ' +
            location +
            ' `' +
            propFullName +
            '` of value `' +
            propValue +
            '` ' +
            ('supplied to `' +
              componentName +
              '`, expected one of ' +
              valuesString +
              '.'),
        );
      }
      return createChainableTypeChecker(validate);
    }

    function createObjectOfTypeChecker(typeChecker) {
      function validate(
        props,
        propName,
        componentName,
        location,
        propFullName,
      ) {
        if (typeof typeChecker !== 'function') {
          return new PropTypeError(
            'Property `' +
              propFullName +
              '` of component `' +
              componentName +
              '` has invalid PropType notation inside objectOf.',
          );
        }
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== 'object') {
          return new PropTypeError(
            'Invalid ' +
              location +
              ' `' +
              propFullName +
              '` of type ' +
              ('`' +
                propType +
                '` supplied to `' +
                componentName +
                '`, expected an object.'),
          );
        }
        for (var key in propValue) {
          if (propValue.hasOwnProperty(key)) {
            var error = typeChecker(
              propValue,
              key,
              componentName,
              location,
              propFullName + '.' + key,
              ReactPropTypesSecret_1,
            );
            if (error instanceof Error) {
              return error;
            }
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }

    function createUnionTypeChecker(arrayOfTypeCheckers) {
      if (!Array.isArray(arrayOfTypeCheckers)) {
        printWarning$1(
          'Invalid argument supplied to oneOfType, expected an instance of array.',
        );
        return emptyFunctionThatReturnsNull;
      }

      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (typeof checker !== 'function') {
          printWarning$1(
            'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
              'received ' +
              getPostfixForTypeWarning(checker) +
              ' at index ' +
              i +
              '.',
          );
          return emptyFunctionThatReturnsNull;
        }
      }

      function validate(
        props,
        propName,
        componentName,
        location,
        propFullName,
      ) {
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          if (
            checker(
              props,
              propName,
              componentName,
              location,
              propFullName,
              ReactPropTypesSecret_1,
            ) == null
          ) {
            return null;
          }
        }

        return new PropTypeError(
          'Invalid ' +
            location +
            ' `' +
            propFullName +
            '` supplied to ' +
            ('`' + componentName + '`.'),
        );
      }
      return createChainableTypeChecker(validate);
    }

    function createNodeChecker() {
      function validate(
        props,
        propName,
        componentName,
        location,
        propFullName,
      ) {
        if (!isNode(props[propName])) {
          return new PropTypeError(
            'Invalid ' +
              location +
              ' `' +
              propFullName +
              '` supplied to ' +
              ('`' + componentName + '`, expected a ReactNode.'),
          );
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }

    function createShapeTypeChecker(shapeTypes) {
      function validate(
        props,
        propName,
        componentName,
        location,
        propFullName,
      ) {
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== 'object') {
          return new PropTypeError(
            'Invalid ' +
              location +
              ' `' +
              propFullName +
              '` of type `' +
              propType +
              '` ' +
              ('supplied to `' + componentName + '`, expected `object`.'),
          );
        }
        for (var key in shapeTypes) {
          var checker = shapeTypes[key];
          if (!checker) {
            continue;
          }
          var error = checker(
            propValue,
            key,
            componentName,
            location,
            propFullName + '.' + key,
            ReactPropTypesSecret_1,
          );
          if (error) {
            return error;
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }

    function createStrictShapeTypeChecker(shapeTypes) {
      function validate(
        props,
        propName,
        componentName,
        location,
        propFullName,
      ) {
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== 'object') {
          return new PropTypeError(
            'Invalid ' +
              location +
              ' `' +
              propFullName +
              '` of type `' +
              propType +
              '` ' +
              ('supplied to `' + componentName + '`, expected `object`.'),
          );
        }
        // We need to check all keys in case some are required but missing from
        // props.
        var allKeys = objectAssign({}, props[propName], shapeTypes);
        for (var key in allKeys) {
          var checker = shapeTypes[key];
          if (!checker) {
            return new PropTypeError(
              'Invalid ' +
                location +
                ' `' +
                propFullName +
                '` key `' +
                key +
                '` supplied to `' +
                componentName +
                '`.' +
                '\nBad object: ' +
                JSON.stringify(props[propName], null, '  ') +
                '\nValid keys: ' +
                JSON.stringify(Object.keys(shapeTypes), null, '  '),
            );
          }
          var error = checker(
            propValue,
            key,
            componentName,
            location,
            propFullName + '.' + key,
            ReactPropTypesSecret_1,
          );
          if (error) {
            return error;
          }
        }
        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function isNode(propValue) {
      switch (typeof propValue) {
        case 'number':
        case 'string':
        case 'undefined':
          return true;
        case 'boolean':
          return !propValue;
        case 'object':
          if (Array.isArray(propValue)) {
            return propValue.every(isNode);
          }
          if (propValue === null || isValidElement(propValue)) {
            return true;
          }

          var iteratorFn = getIteratorFn(propValue);
          if (iteratorFn) {
            var iterator = iteratorFn.call(propValue);
            var step;
            if (iteratorFn !== propValue.entries) {
              while (!(step = iterator.next()).done) {
                if (!isNode(step.value)) {
                  return false;
                }
              }
            } else {
              // Iterator will provide entry [k,v] tuples rather than values.
              while (!(step = iterator.next()).done) {
                var entry = step.value;
                if (entry) {
                  if (!isNode(entry[1])) {
                    return false;
                  }
                }
              }
            }
          } else {
            return false;
          }

          return true;
        default:
          return false;
      }
    }

    function isSymbol(propType, propValue) {
      // Native Symbol.
      if (propType === 'symbol') {
        return true;
      }

      // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
      if (propValue['@@toStringTag'] === 'Symbol') {
        return true;
      }

      // Fallback for non-spec compliant Symbols which are polyfilled.
      if (typeof Symbol === 'function' && propValue instanceof Symbol) {
        return true;
      }

      return false;
    }

    // Equivalent of `typeof` but with special handling for array and regexp.
    function getPropType(propValue) {
      var propType = typeof propValue;
      if (Array.isArray(propValue)) {
        return 'array';
      }
      if (propValue instanceof RegExp) {
        // Old webkits (at least until Android 4.0) return 'function' rather than
        // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
        // passes PropTypes.object.
        return 'object';
      }
      if (isSymbol(propType, propValue)) {
        return 'symbol';
      }
      return propType;
    }

    // This handles more types than `getPropType`. Only used for error messages.
    // See `createPrimitiveTypeChecker`.
    function getPreciseType(propValue) {
      if (typeof propValue === 'undefined' || propValue === null) {
        return '' + propValue;
      }
      var propType = getPropType(propValue);
      if (propType === 'object') {
        if (propValue instanceof Date) {
          return 'date';
        } else if (propValue instanceof RegExp) {
          return 'regexp';
        }
      }
      return propType;
    }

    // Returns a string that is postfixed to a warning about an invalid type.
    // For example, "undefined" or "of type array"
    function getPostfixForTypeWarning(value) {
      var type = getPreciseType(value);
      switch (type) {
        case 'array':
        case 'object':
          return 'an ' + type;
        case 'boolean':
        case 'date':
        case 'regexp':
          return 'a ' + type;
        default:
          return type;
      }
    }

    // Returns class name of the object, if any.
    function getClassName(propValue) {
      if (!propValue.constructor || !propValue.constructor.name) {
        return ANONYMOUS;
      }
      return propValue.constructor.name;
    }

    ReactPropTypes.checkPropTypes = checkPropTypes_1;
    ReactPropTypes.PropTypes = ReactPropTypes;

    return ReactPropTypes;
  };

  var propTypes = createCommonjsModule(function(module) {
    /**
     * Copyright (c) 2013-present, Facebook, Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    {
      var REACT_ELEMENT_TYPE =
        (typeof Symbol === 'function' &&
          Symbol.for &&
          Symbol.for('react.element')) ||
        0xeac7;

      var isValidElement = function(object) {
        return (
          typeof object === 'object' &&
          object !== null &&
          object.$$typeof === REACT_ELEMENT_TYPE
        );
      };

      // By explicitly using `prop-types` you are opting into new development behavior.
      // http://fb.me/prop-types-in-prod
      var throwOnDirectAccess = true;
      module.exports = factoryWithTypeCheckers(
        isValidElement,
        throwOnDirectAccess,
      );
    }
  });

  var msPerFrame = 1000 / 60;

  var Motion =
    /*#__PURE__*/
    (function(_React$Component) {
      _inheritsLoose(Motion, _React$Component);

      function Motion(props) {
        var _this;

        _this = _React$Component.call(this, props) || this;
        _this.unmounting = false;
        _this.wasAnimating = false;
        _this.animationID = null;
        _this.prevTime = 0;
        _this.accumulatedTime = 0;
        _this.unreadPropStyle = null;

        _this.clearUnreadPropStyle = function(destStyle) {
          var dirty = false;
          var _this$state = _this.state,
            currentStyle = _this$state.currentStyle,
            currentVelocity = _this$state.currentVelocity,
            lastIdealStyle = _this$state.lastIdealStyle,
            lastIdealVelocity = _this$state.lastIdealVelocity;

          for (var key in destStyle) {
            if (!Object.prototype.hasOwnProperty.call(destStyle, key)) {
              continue;
            }

            var styleValue = destStyle[key];

            if (typeof styleValue === 'number') {
              if (!dirty) {
                dirty = true;
                currentStyle = _extends({}, currentStyle);
                currentVelocity = _extends({}, currentVelocity);
                lastIdealStyle = _extends({}, lastIdealStyle);
                lastIdealVelocity = _extends({}, lastIdealVelocity);
              }

              currentStyle[key] = styleValue;
              currentVelocity[key] = 0;
              lastIdealStyle[key] = styleValue;
              lastIdealVelocity[key] = 0;
            }
          }

          if (dirty) {
            _this.setState({
              currentStyle: currentStyle,
              currentVelocity: currentVelocity,
              lastIdealStyle: lastIdealStyle,
              lastIdealVelocity: lastIdealVelocity,
            });
          }
        };

        _this.startAnimationIfNecessary = function() {
          if (_this.unmounting || _this.animationID != null) {
            return;
          } // TODO: when config is {a: 10} and dest is {a: 10} do we raf once and
          // call cb? No, otherwise accidental parent rerender causes cb trigger

          _this.animationID = raf_1(function(timestamp) {
            // https://github.com/chenglou/react-motion/pull/420
            // > if execution passes the conditional if (this.unmounting), then
            // executes async defaultRaf and after that component unmounts and after
            // that the callback of defaultRaf is called, then setState will be called
            // on unmounted component.
            if (_this.unmounting) {
              return;
            } // check if we need to animate in the first place

            var propsStyle = _this.props.style;

            if (
              shouldStopAnimation(
                _this.state.currentStyle,
                propsStyle,
                _this.state.currentVelocity,
              )
            ) {
              if (_this.wasAnimating && _this.props.onRest) {
                _this.props.onRest();
              } // no need to cancel animationID here; shouldn't have any in flight

              _this.animationID = null;
              _this.wasAnimating = false;
              _this.accumulatedTime = 0;
              return;
            }

            _this.wasAnimating = true;
            var currentTime = timestamp || performanceNow();
            var timeDelta = currentTime - _this.prevTime;
            _this.prevTime = currentTime;
            _this.accumulatedTime = _this.accumulatedTime + timeDelta; // more than 10 frames? prolly switched browser tab. Restart

            if (_this.accumulatedTime > msPerFrame * 10) {
              _this.accumulatedTime = 0;
            }

            if (_this.accumulatedTime === 0) {
              // no need to cancel animationID here; shouldn't have any in flight
              _this.animationID = null;

              _this.startAnimationIfNecessary();

              return;
            }

            var currentFrameCompletion =
              (_this.accumulatedTime -
                Math.floor(_this.accumulatedTime / msPerFrame) * msPerFrame) /
              msPerFrame;
            var framesToCatchUp = Math.floor(
              _this.accumulatedTime / msPerFrame,
            );
            var newLastIdealStyle = {};
            var newLastIdealVelocity = {};
            var newCurrentStyle = {};
            var newCurrentVelocity = {};

            for (var key in propsStyle) {
              if (!Object.prototype.hasOwnProperty.call(propsStyle, key)) {
                continue;
              }

              var styleValue = propsStyle[key];

              if (typeof styleValue === 'number') {
                newCurrentStyle[key] = styleValue;
                newCurrentVelocity[key] = 0;
                newLastIdealStyle[key] = styleValue;
                newLastIdealVelocity[key] = 0;
              } else {
                var newLastIdealStyleValue = _this.state.lastIdealStyle[key];
                var newLastIdealVelocityValue =
                  _this.state.lastIdealVelocity[key];

                for (var i = 0; i < framesToCatchUp; i++) {
                  var _stepper = stepper(
                    msPerFrame / 1000,
                    newLastIdealStyleValue,
                    newLastIdealVelocityValue,
                    styleValue.val,
                    styleValue.stiffness,
                    styleValue.damping,
                    styleValue.precision,
                  );

                  newLastIdealStyleValue = _stepper[0];
                  newLastIdealVelocityValue = _stepper[1];
                }

                var _stepper2 = stepper(
                    msPerFrame / 1000,
                    newLastIdealStyleValue,
                    newLastIdealVelocityValue,
                    styleValue.val,
                    styleValue.stiffness,
                    styleValue.damping,
                    styleValue.precision,
                  ),
                  nextIdealX = _stepper2[0],
                  nextIdealV = _stepper2[1];

                newCurrentStyle[key] =
                  newLastIdealStyleValue +
                  (nextIdealX - newLastIdealStyleValue) *
                    currentFrameCompletion;
                newCurrentVelocity[key] =
                  newLastIdealVelocityValue +
                  (nextIdealV - newLastIdealVelocityValue) *
                    currentFrameCompletion;
                newLastIdealStyle[key] = newLastIdealStyleValue;
                newLastIdealVelocity[key] = newLastIdealVelocityValue;
              }
            }

            _this.animationID = null; // the amount we're looped over above

            _this.accumulatedTime -= framesToCatchUp * msPerFrame;

            _this.setState({
              currentStyle: newCurrentStyle,
              currentVelocity: newCurrentVelocity,
              lastIdealStyle: newLastIdealStyle,
              lastIdealVelocity: newLastIdealVelocity,
            });

            _this.unreadPropStyle = null;

            _this.startAnimationIfNecessary();
          });
        };

        _this.state = _this.defaultState();
        return _this;
      }

      var _proto = Motion.prototype;

      _proto.defaultState = function defaultState() {
        var _this$props = this.props,
          defaultStyle = _this$props.defaultStyle,
          style = _this$props.style;
        var currentStyle = defaultStyle || stripStyle(style);
        var currentVelocity = mapToZero(currentStyle);
        return {
          currentStyle: currentStyle,
          currentVelocity: currentVelocity,
          lastIdealStyle: currentStyle,
          lastIdealVelocity: currentVelocity,
        };
      }; // it's possible that currentStyle's value is stale: if props is immediately
      // changed from 0 to 400 to spring(0) again, the async currentStyle is still
      // at 0 (didn't have time to tick and interpolate even once). If we naively
      // compare currentStyle with destVal it'll be 0 === 0 (no animation, stop).
      // In reality currentStyle should be 400

      _proto.componentDidMount = function componentDidMount() {
        this.prevTime = performanceNow();
        this.startAnimationIfNecessary();
      };

      _proto.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(
        props,
      ) {
        if (this.unreadPropStyle != null) {
          // previous props haven't had the chance to be set yet; set them here
          this.clearUnreadPropStyle(this.unreadPropStyle);
        }

        this.unreadPropStyle = props.style;

        if (this.animationID == null) {
          this.prevTime = performanceNow();
          this.startAnimationIfNecessary();
        }
      };

      _proto.componentWillUnmount = function componentWillUnmount() {
        this.unmounting = true;

        if (this.animationID != null) {
          raf_1.cancel(this.animationID);
          this.animationID = null;
        }
      };

      _proto.render = function render() {
        var renderedChildren = this.props.children(this.state.currentStyle);
        return renderedChildren && React.Children.only(renderedChildren);
      };

      return Motion;
    })(React.Component);
  Motion.propTypes = {
    // TOOD: warn against putting a config in here
    defaultStyle: propTypes.objectOf(propTypes.number),
    style: propTypes.objectOf(
      propTypes.oneOfType([propTypes.number, propTypes.object]),
    ).isRequired,
    children: propTypes.func.isRequired,
    onRest: propTypes.func,
  };

  var msPerFrame$1 = 1000 / 60;

  function shouldStopAnimationAll(currentStyles, styles, currentVelocities) {
    for (var i = 0; i < currentStyles.length; i++) {
      if (
        !shouldStopAnimation(currentStyles[i], styles[i], currentVelocities[i])
      ) {
        return false;
      }
    }

    return true;
  }

  var StaggeredMotion =
    /*#__PURE__*/
    (function(_React$Component) {
      _inheritsLoose(StaggeredMotion, _React$Component);

      function StaggeredMotion(props) {
        var _this;

        _this = _React$Component.call(this, props) || this;
        _this.unmounting = false;
        _this.animationID = null;
        _this.prevTime = 0;
        _this.accumulatedTime = 0;
        _this.unreadPropStyles = null;

        _this.clearUnreadPropStyle = function(unreadPropStyles) {
          var _this$state = _this.state,
            currentStyles = _this$state.currentStyles,
            currentVelocities = _this$state.currentVelocities,
            lastIdealStyles = _this$state.lastIdealStyles,
            lastIdealVelocities = _this$state.lastIdealVelocities;
          var someDirty = false;

          for (var i = 0; i < unreadPropStyles.length; i++) {
            var unreadPropStyle = unreadPropStyles[i];
            var dirty = false;

            for (var key in unreadPropStyle) {
              if (!Object.prototype.hasOwnProperty.call(unreadPropStyle, key)) {
                continue;
              }

              var styleValue = unreadPropStyle[key];

              if (typeof styleValue === 'number') {
                if (!dirty) {
                  dirty = true;
                  someDirty = true;
                  currentStyles[i] = _extends({}, currentStyles[i]);
                  currentVelocities[i] = _extends({}, currentVelocities[i]);
                  lastIdealStyles[i] = _extends({}, lastIdealStyles[i]);
                  lastIdealVelocities[i] = _extends({}, lastIdealVelocities[i]);
                }

                currentStyles[i][key] = styleValue;
                currentVelocities[i][key] = 0;
                lastIdealStyles[i][key] = styleValue;
                lastIdealVelocities[i][key] = 0;
              }
            }
          }

          if (someDirty) {
            _this.setState({
              currentStyles: currentStyles,
              currentVelocities: currentVelocities,
              lastIdealStyles: lastIdealStyles,
              lastIdealVelocities: lastIdealVelocities,
            });
          }
        };

        _this.startAnimationIfNecessary = function() {
          if (_this.unmounting || _this.animationID != null) {
            return;
          } // TODO: when config is {a: 10} and dest is {a: 10} do we raf once and
          // call cb? No, otherwise accidental parent rerender causes cb trigger

          _this.animationID = raf_1(function(timestamp) {
            // https://github.com/chenglou/react-motion/pull/420
            // > if execution passes the conditional if (this.unmounting), then
            // executes async defaultRaf and after that component unmounts and after
            // that the callback of defaultRaf is called, then setState will be called
            // on unmounted component.
            if (_this.unmounting) {
              return;
            }

            var destStyles = _this.props.styles(_this.state.lastIdealStyles); // check if we need to animate in the first place

            if (
              shouldStopAnimationAll(
                _this.state.currentStyles,
                destStyles,
                _this.state.currentVelocities,
              )
            ) {
              // no need to cancel animationID here; shouldn't have any in flight
              _this.animationID = null;
              _this.accumulatedTime = 0;
              return;
            }

            var currentTime = timestamp || performanceNow();
            var timeDelta = currentTime - _this.prevTime;
            _this.prevTime = currentTime;
            _this.accumulatedTime = _this.accumulatedTime + timeDelta; // more than 10 frames? prolly switched browser tab. Restart

            if (_this.accumulatedTime > msPerFrame$1 * 10) {
              _this.accumulatedTime = 0;
            }

            if (_this.accumulatedTime === 0) {
              // no need to cancel animationID here; shouldn't have any in flight
              _this.animationID = null;

              _this.startAnimationIfNecessary();

              return;
            }

            var currentFrameCompletion =
              (_this.accumulatedTime -
                Math.floor(_this.accumulatedTime / msPerFrame$1) *
                  msPerFrame$1) /
              msPerFrame$1;
            var framesToCatchUp = Math.floor(
              _this.accumulatedTime / msPerFrame$1,
            );
            var newLastIdealStyles = [];
            var newLastIdealVelocities = [];
            var newCurrentStyles = [];
            var newCurrentVelocities = [];

            for (var i = 0; i < destStyles.length; i++) {
              var destStyle = destStyles[i];
              var newCurrentStyle = {};
              var newCurrentVelocity = {};
              var newLastIdealStyle = {};
              var newLastIdealVelocity = {};

              for (var key in destStyle) {
                if (!Object.prototype.hasOwnProperty.call(destStyle, key)) {
                  continue;
                }

                var styleValue = destStyle[key];

                if (typeof styleValue === 'number') {
                  newCurrentStyle[key] = styleValue;
                  newCurrentVelocity[key] = 0;
                  newLastIdealStyle[key] = styleValue;
                  newLastIdealVelocity[key] = 0;
                } else {
                  var newLastIdealStyleValue =
                    _this.state.lastIdealStyles[i][key];
                  var newLastIdealVelocityValue =
                    _this.state.lastIdealVelocities[i][key];

                  for (var j = 0; j < framesToCatchUp; j++) {
                    var _stepper = stepper(
                      msPerFrame$1 / 1000,
                      newLastIdealStyleValue,
                      newLastIdealVelocityValue,
                      styleValue.val,
                      styleValue.stiffness,
                      styleValue.damping,
                      styleValue.precision,
                    );

                    newLastIdealStyleValue = _stepper[0];
                    newLastIdealVelocityValue = _stepper[1];
                  }

                  var _stepper2 = stepper(
                      msPerFrame$1 / 1000,
                      newLastIdealStyleValue,
                      newLastIdealVelocityValue,
                      styleValue.val,
                      styleValue.stiffness,
                      styleValue.damping,
                      styleValue.precision,
                    ),
                    nextIdealX = _stepper2[0],
                    nextIdealV = _stepper2[1];

                  newCurrentStyle[key] =
                    newLastIdealStyleValue +
                    (nextIdealX - newLastIdealStyleValue) *
                      currentFrameCompletion;
                  newCurrentVelocity[key] =
                    newLastIdealVelocityValue +
                    (nextIdealV - newLastIdealVelocityValue) *
                      currentFrameCompletion;
                  newLastIdealStyle[key] = newLastIdealStyleValue;
                  newLastIdealVelocity[key] = newLastIdealVelocityValue;
                }
              }

              newCurrentStyles[i] = newCurrentStyle;
              newCurrentVelocities[i] = newCurrentVelocity;
              newLastIdealStyles[i] = newLastIdealStyle;
              newLastIdealVelocities[i] = newLastIdealVelocity;
            }

            _this.animationID = null; // the amount we're looped over above

            _this.accumulatedTime -= framesToCatchUp * msPerFrame$1;

            _this.setState({
              currentStyles: newCurrentStyles,
              currentVelocities: newCurrentVelocities,
              lastIdealStyles: newLastIdealStyles,
              lastIdealVelocities: newLastIdealVelocities,
            });

            _this.unreadPropStyles = null;

            _this.startAnimationIfNecessary();
          });
        };

        _this.state = _this.defaultState();
        return _this;
      }

      var _proto = StaggeredMotion.prototype;

      _proto.defaultState = function defaultState() {
        var _this$props = this.props,
          defaultStyles = _this$props.defaultStyles,
          styles = _this$props.styles;
        var currentStyles = defaultStyles || styles().map(stripStyle);
        var currentVelocities = currentStyles.map(function(currentStyle) {
          return mapToZero(currentStyle);
        });
        return {
          currentStyles: currentStyles,
          currentVelocities: currentVelocities,
          lastIdealStyles: currentStyles,
          lastIdealVelocities: currentVelocities,
        };
      };

      _proto.componentDidMount = function componentDidMount() {
        this.prevTime = performanceNow();
        this.startAnimationIfNecessary();
      };

      _proto.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(
        props,
      ) {
        if (this.unreadPropStyles != null) {
          // previous props haven't had the chance to be set yet; set them here
          this.clearUnreadPropStyle(this.unreadPropStyles);
        }

        this.unreadPropStyles = props.styles(this.state.lastIdealStyles);

        if (this.animationID == null) {
          this.prevTime = performanceNow();
          this.startAnimationIfNecessary();
        }
      };

      _proto.componentWillUnmount = function componentWillUnmount() {
        this.unmounting = true;

        if (this.animationID != null) {
          raf_1.cancel(this.animationID);
          this.animationID = null;
        }
      };

      _proto.render = function render() {
        var renderedChildren = this.props.children(this.state.currentStyles);
        return renderedChildren && React.Children.only(renderedChildren);
      };

      return StaggeredMotion;
    })(React.Component);
  StaggeredMotion.propTypes = {
    // TOOD: warn against putting a config in here
    defaultStyles: propTypes.arrayOf(propTypes.objectOf(propTypes.number)),
    styles: propTypes.func.isRequired,
    children: propTypes.func.isRequired,
  };

  // core keys merging algorithm. If previous render's keys are [a, b], and the
  // next render's [c, b, d], what's the final merged keys and ordering?
  // - c and a must both be before b
  // - b before d
  // - ordering between a and c ambiguous
  // this reduces to merging two partially ordered lists (e.g. lists where not
  // every item has a definite ordering, like comparing a and c above). For the
  // ambiguous ordering we deterministically choose to place the next render's
  // item after the previous'; so c after a
  // this is called a topological sorting. Except the existing algorithms don't
  // work well with js bc of the amount of allocation, and isn't optimized for our
  // current use-case bc the runtime is linear in terms of edges (see wiki for
  // meaning), which is huge when two lists have many common elements
  function mergeDiff(prev, next, onRemove) {
    // bookkeeping for easier access of a key's index below. This is 2 allocations +
    // potentially triggering chrome hash map mode for objs (so it might be faster
    // to loop through and find a key's index each time), but I no longer care
    var prevKeyIndex = {};

    for (var i = 0; i < prev.length; i++) {
      prevKeyIndex[prev[i].key] = i;
    }

    var nextKeyIndex = {};

    for (var _i = 0; _i < next.length; _i++) {
      nextKeyIndex[next[_i].key] = _i;
    } // first, an overly elaborate way of merging prev and next, eliminating
    // duplicates (in terms of keys). If there's dupe, keep the item in next).
    // This way of writing it saves allocations

    var ret = [];

    for (var _i2 = 0; _i2 < next.length; _i2++) {
      ret[_i2] = next[_i2];
    }

    for (var _i3 = 0; _i3 < prev.length; _i3++) {
      if (!Object.prototype.hasOwnProperty.call(nextKeyIndex, prev[_i3].key)) {
        // this is called my TM's `mergeAndSync`, which calls willLeave. We don't
        // merge in keys that the user desires to kill
        var fill = onRemove(_i3, prev[_i3]);

        if (fill != null) {
          ret.push(fill);
        }
      }
    } // now all the items all present. Core sorting logic to have the right order

    return ret.sort(function(a, b) {
      var nextOrderA = nextKeyIndex[a.key];
      var nextOrderB = nextKeyIndex[b.key];
      var prevOrderA = prevKeyIndex[a.key];
      var prevOrderB = prevKeyIndex[b.key];

      if (nextOrderA != null && nextOrderB != null) {
        // both keys in next
        return nextKeyIndex[a.key] - nextKeyIndex[b.key];
      } else if (prevOrderA != null && prevOrderB != null) {
        // both keys in prev
        return prevKeyIndex[a.key] - prevKeyIndex[b.key];
      } else if (nextOrderA != null) {
        // key a in next, key b in prev
        // how to determine the order between a and b? We find a "pivot" (term
        // abuse), a key present in both prev and next, that is sandwiched between
        // a and b. In the context of our above example, if we're comparing a and
        // d, b's (the only) pivot
        for (var _i4 = 0; _i4 < next.length; _i4++) {
          var pivot = next[_i4].key;

          if (!Object.prototype.hasOwnProperty.call(prevKeyIndex, pivot)) {
            continue;
          }

          if (
            nextOrderA < nextKeyIndex[pivot] &&
            prevOrderB > prevKeyIndex[pivot]
          ) {
            return -1;
          } else if (
            nextOrderA > nextKeyIndex[pivot] &&
            prevOrderB < prevKeyIndex[pivot]
          ) {
            return 1;
          }
        } // pluggable. default to: next bigger than prev

        return 1;
      } // prevOrderA, nextOrderB

      for (var _i5 = 0; _i5 < next.length; _i5++) {
        var _pivot = next[_i5].key;

        if (!Object.prototype.hasOwnProperty.call(prevKeyIndex, _pivot)) {
          continue;
        }

        if (
          nextOrderB < nextKeyIndex[_pivot] &&
          prevOrderA > prevKeyIndex[_pivot]
        ) {
          return 1;
        } else if (
          nextOrderB > nextKeyIndex[_pivot] &&
          prevOrderA < prevKeyIndex[_pivot]
        ) {
          return -1;
        }
      } // pluggable. default to: next bigger than prev

      return -1;
    });
  }

  var msPerFrame$2 = 1000 / 60; // the children function & (potential) styles function asks as param an
  // Array<TransitionPlainStyle>, where each TransitionPlainStyle is of the format
  // {key: string, data?: any, style: PlainStyle}. However, the way we keep
  // internal states doesn't contain such a data structure (check the state and
  // TransitionMotionState). So when children function and others ask for such
  // data we need to generate them on the fly by combining mergedPropsStyles and
  // currentStyles/lastIdealStyles

  function rehydrateStyles(mergedPropsStyles, unreadPropStyles, plainStyles) {
    // Copy the value to a `const` so that Flow understands that the const won't
    // change and will be non-nullable in the callback below.
    var cUnreadPropStyles = unreadPropStyles;

    if (cUnreadPropStyles == null) {
      return mergedPropsStyles.map(function(mergedPropsStyle, i) {
        return {
          key: mergedPropsStyle.key,
          data: mergedPropsStyle.data,
          style: plainStyles[i],
        };
      });
    }

    return mergedPropsStyles.map(function(mergedPropsStyle, i) {
      for (var j = 0; j < cUnreadPropStyles.length; j++) {
        if (cUnreadPropStyles[j].key === mergedPropsStyle.key) {
          return {
            key: cUnreadPropStyles[j].key,
            data: cUnreadPropStyles[j].data,
            style: plainStyles[i],
          };
        }
      }

      return {
        key: mergedPropsStyle.key,
        data: mergedPropsStyle.data,
        style: plainStyles[i],
      };
    });
  }

  function shouldStopAnimationAll$1(
    currentStyles,
    destStyles,
    currentVelocities,
    mergedPropsStyles,
  ) {
    if (mergedPropsStyles.length !== destStyles.length) {
      return false;
    }

    for (var i = 0; i < mergedPropsStyles.length; i++) {
      if (mergedPropsStyles[i].key !== destStyles[i].key) {
        return false;
      }
    } // we have the invariant that mergedPropsStyles and
    // currentStyles/currentVelocities/last* are synced in terms of cells, see
    // mergeAndSync comment for more info

    for (var _i = 0; _i < mergedPropsStyles.length; _i++) {
      if (
        !shouldStopAnimation(
          currentStyles[_i],
          destStyles[_i].style,
          currentVelocities[_i],
        )
      ) {
        return false;
      }
    }

    return true;
  } // core key merging logic
  // things to do: say previously merged style is {a, b}, dest style (prop) is {b,
  // c}, previous current (interpolating) style is {a, b}
  // **invariant**: current[i] corresponds to merged[i] in terms of key
  // steps:
  // turn merged style into {a?, b, c}
  //    add c, value of c is destStyles.c
  //    maybe remove a, aka call willLeave(a), then merged is either {b, c} or {a, b, c}
  // turn current (interpolating) style from {a, b} into {a?, b, c}
  //    maybe remove a
  //    certainly add c, value of c is willEnter(c)
  // loop over merged and construct new current
  // dest doesn't change, that's owner's

  function mergeAndSync(
    willEnter,
    willLeave,
    didLeave,
    oldMergedPropsStyles,
    destStyles,
    oldCurrentStyles,
    oldCurrentVelocities,
    oldLastIdealStyles,
    oldLastIdealVelocities,
  ) {
    var newMergedPropsStyles = mergeDiff(
      oldMergedPropsStyles,
      destStyles,
      function(oldIndex, oldMergedPropsStyle) {
        var leavingStyle = willLeave(oldMergedPropsStyle);

        if (leavingStyle == null) {
          didLeave({
            key: oldMergedPropsStyle.key,
            data: oldMergedPropsStyle.data,
          });
          return null;
        }

        if (
          shouldStopAnimation(
            oldCurrentStyles[oldIndex],
            leavingStyle,
            oldCurrentVelocities[oldIndex],
          )
        ) {
          didLeave({
            key: oldMergedPropsStyle.key,
            data: oldMergedPropsStyle.data,
          });
          return null;
        }

        return {
          key: oldMergedPropsStyle.key,
          data: oldMergedPropsStyle.data,
          style: leavingStyle,
        };
      },
    );
    var newCurrentStyles = [];
    var newCurrentVelocities = [];
    var newLastIdealStyles = [];
    var newLastIdealVelocities = [];

    for (var i = 0; i < newMergedPropsStyles.length; i++) {
      var newMergedPropsStyleCell = newMergedPropsStyles[i];
      var foundOldIndex = null;

      for (var j = 0; j < oldMergedPropsStyles.length; j++) {
        if (oldMergedPropsStyles[j].key === newMergedPropsStyleCell.key) {
          foundOldIndex = j;
          break;
        }
      } // TODO: key search code

      if (foundOldIndex == null) {
        var plainStyle = willEnter(newMergedPropsStyleCell);
        newCurrentStyles[i] = plainStyle;
        newLastIdealStyles[i] = plainStyle;
        var velocity = mapToZero(newMergedPropsStyleCell.style);
        newCurrentVelocities[i] = velocity;
        newLastIdealVelocities[i] = velocity;
      } else {
        newCurrentStyles[i] = oldCurrentStyles[foundOldIndex];
        newLastIdealStyles[i] = oldLastIdealStyles[foundOldIndex];
        newCurrentVelocities[i] = oldCurrentVelocities[foundOldIndex];
        newLastIdealVelocities[i] = oldLastIdealVelocities[foundOldIndex];
      }
    }

    return [
      newMergedPropsStyles,
      newCurrentStyles,
      newCurrentVelocities,
      newLastIdealStyles,
      newLastIdealVelocities,
    ];
  }

  var TransitionMotion =
    /*#__PURE__*/
    (function(_React$Component) {
      _inheritsLoose(TransitionMotion, _React$Component);

      // it's possible that currentStyle's value is stale: if props is immediately
      // changed from 0 to 400 to spring(0) again, the async currentStyle is still
      // at 0 (didn't have time to tick and interpolate even once). If we naively
      // compare currentStyle with destVal it'll be 0 === 0 (no animation, stop).
      // In reality currentStyle should be 400
      function TransitionMotion(props) {
        var _this;

        _this = _React$Component.call(this, props) || this;
        _this.unmounting = false;
        _this.animationID = null;
        _this.prevTime = 0;
        _this.accumulatedTime = 0;
        _this.unreadPropStyles = null;

        _this.clearUnreadPropStyle = function(unreadPropStyles) {
          var _mergeAndSync = mergeAndSync(
              _this.props.willEnter,
              _this.props.willLeave,
              _this.props.didLeave,
              _this.state.mergedPropsStyles,
              unreadPropStyles,
              _this.state.currentStyles,
              _this.state.currentVelocities,
              _this.state.lastIdealStyles,
              _this.state.lastIdealVelocities,
            ),
            mergedPropsStyles = _mergeAndSync[0],
            currentStyles = _mergeAndSync[1],
            currentVelocities = _mergeAndSync[2],
            lastIdealStyles = _mergeAndSync[3],
            lastIdealVelocities = _mergeAndSync[4];

          for (var i = 0; i < unreadPropStyles.length; i++) {
            var unreadPropStyle = unreadPropStyles[i].style;
            var dirty = false;

            for (var key in unreadPropStyle) {
              if (!Object.prototype.hasOwnProperty.call(unreadPropStyle, key)) {
                continue;
              }

              var styleValue = unreadPropStyle[key];

              if (typeof styleValue === 'number') {
                if (!dirty) {
                  dirty = true;
                  currentStyles[i] = _extends({}, currentStyles[i]);
                  currentVelocities[i] = _extends({}, currentVelocities[i]);
                  lastIdealStyles[i] = _extends({}, lastIdealStyles[i]);
                  lastIdealVelocities[i] = _extends({}, lastIdealVelocities[i]);
                  mergedPropsStyles[i] = {
                    key: mergedPropsStyles[i].key,
                    data: mergedPropsStyles[i].data,
                    style: _extends({}, mergedPropsStyles[i].style),
                  };
                }

                currentStyles[i][key] = styleValue;
                currentVelocities[i][key] = 0;
                lastIdealStyles[i][key] = styleValue;
                lastIdealVelocities[i][key] = 0;
                mergedPropsStyles[i].style[key] = styleValue;
              }
            }
          } // unlike the other 2 components, we can't detect staleness and optionally
          // opt out of setState here. each style object's data might contain new
          // stuff we're not/cannot compare

          _this.setState({
            currentStyles: currentStyles,
            currentVelocities: currentVelocities,
            mergedPropsStyles: mergedPropsStyles,
            lastIdealStyles: lastIdealStyles,
            lastIdealVelocities: lastIdealVelocities,
          });
        };

        _this.startAnimationIfNecessary = function() {
          if (_this.unmounting || _this.animationID != null) {
            return;
          } // TODO: when config is {a: 10} and dest is {a: 10} do we raf once and
          // call cb? No, otherwise accidental parent rerender causes cb trigger

          _this.animationID = raf_1(function(timestamp) {
            // https://github.com/chenglou/react-motion/pull/420
            // > if execution passes the conditional if (this.unmounting), then
            // executes async defaultRaf and after that component unmounts and after
            // that the callback of defaultRaf is called, then setState will be called
            // on unmounted component.
            if (_this.unmounting) {
              return;
            }

            var propStyles = _this.props.styles;
            var destStyles =
              typeof propStyles === 'function'
                ? propStyles(
                    rehydrateStyles(
                      _this.state.mergedPropsStyles,
                      _this.unreadPropStyles,
                      _this.state.lastIdealStyles,
                    ),
                  )
                : propStyles; // check if we need to animate in the first place

            if (
              shouldStopAnimationAll$1(
                _this.state.currentStyles,
                destStyles,
                _this.state.currentVelocities,
                _this.state.mergedPropsStyles,
              )
            ) {
              // no need to cancel animationID here; shouldn't have any in flight
              _this.animationID = null;
              _this.accumulatedTime = 0;
              return;
            }

            var currentTime = timestamp || performanceNow();
            var timeDelta = currentTime - _this.prevTime;
            _this.prevTime = currentTime;
            _this.accumulatedTime = _this.accumulatedTime + timeDelta; // more than 10 frames? prolly switched browser tab. Restart

            if (_this.accumulatedTime > msPerFrame$2 * 10) {
              _this.accumulatedTime = 0;
            }

            if (_this.accumulatedTime === 0) {
              // no need to cancel animationID here; shouldn't have any in flight
              _this.animationID = null;

              _this.startAnimationIfNecessary();

              return;
            }

            var currentFrameCompletion =
              (_this.accumulatedTime -
                Math.floor(_this.accumulatedTime / msPerFrame$2) *
                  msPerFrame$2) /
              msPerFrame$2;
            var framesToCatchUp = Math.floor(
              _this.accumulatedTime / msPerFrame$2,
            );

            var _mergeAndSync2 = mergeAndSync(
                _this.props.willEnter,
                _this.props.willLeave,
                _this.props.didLeave,
                _this.state.mergedPropsStyles,
                destStyles,
                _this.state.currentStyles,
                _this.state.currentVelocities,
                _this.state.lastIdealStyles,
                _this.state.lastIdealVelocities,
              ),
              newMergedPropsStyles = _mergeAndSync2[0],
              newCurrentStyles = _mergeAndSync2[1],
              newCurrentVelocities = _mergeAndSync2[2],
              newLastIdealStyles = _mergeAndSync2[3],
              newLastIdealVelocities = _mergeAndSync2[4];

            for (var i = 0; i < newMergedPropsStyles.length; i++) {
              var newMergedPropsStyle = newMergedPropsStyles[i].style;
              var newCurrentStyle = {};
              var newCurrentVelocity = {};
              var newLastIdealStyle = {};
              var newLastIdealVelocity = {};

              for (var key in newMergedPropsStyle) {
                if (
                  !Object.prototype.hasOwnProperty.call(
                    newMergedPropsStyle,
                    key,
                  )
                ) {
                  continue;
                }

                var styleValue = newMergedPropsStyle[key];

                if (typeof styleValue === 'number') {
                  newCurrentStyle[key] = styleValue;
                  newCurrentVelocity[key] = 0;
                  newLastIdealStyle[key] = styleValue;
                  newLastIdealVelocity[key] = 0;
                } else {
                  var newLastIdealStyleValue = newLastIdealStyles[i][key];
                  var newLastIdealVelocityValue =
                    newLastIdealVelocities[i][key];

                  for (var j = 0; j < framesToCatchUp; j++) {
                    var _stepper = stepper(
                      msPerFrame$2 / 1000,
                      newLastIdealStyleValue,
                      newLastIdealVelocityValue,
                      styleValue.val,
                      styleValue.stiffness,
                      styleValue.damping,
                      styleValue.precision,
                    );

                    newLastIdealStyleValue = _stepper[0];
                    newLastIdealVelocityValue = _stepper[1];
                  }

                  var _stepper2 = stepper(
                      msPerFrame$2 / 1000,
                      newLastIdealStyleValue,
                      newLastIdealVelocityValue,
                      styleValue.val,
                      styleValue.stiffness,
                      styleValue.damping,
                      styleValue.precision,
                    ),
                    nextIdealX = _stepper2[0],
                    nextIdealV = _stepper2[1];

                  newCurrentStyle[key] =
                    newLastIdealStyleValue +
                    (nextIdealX - newLastIdealStyleValue) *
                      currentFrameCompletion;
                  newCurrentVelocity[key] =
                    newLastIdealVelocityValue +
                    (nextIdealV - newLastIdealVelocityValue) *
                      currentFrameCompletion;
                  newLastIdealStyle[key] = newLastIdealStyleValue;
                  newLastIdealVelocity[key] = newLastIdealVelocityValue;
                }
              }

              newLastIdealStyles[i] = newLastIdealStyle;
              newLastIdealVelocities[i] = newLastIdealVelocity;
              newCurrentStyles[i] = newCurrentStyle;
              newCurrentVelocities[i] = newCurrentVelocity;
            }

            _this.animationID = null; // the amount we're looped over above

            _this.accumulatedTime -= framesToCatchUp * msPerFrame$2;

            _this.setState({
              currentStyles: newCurrentStyles,
              currentVelocities: newCurrentVelocities,
              lastIdealStyles: newLastIdealStyles,
              lastIdealVelocities: newLastIdealVelocities,
              mergedPropsStyles: newMergedPropsStyles,
            });

            _this.unreadPropStyles = null;

            _this.startAnimationIfNecessary();
          });
        };

        _this.state = _this.defaultState();
        return _this;
      }

      var _proto = TransitionMotion.prototype;

      _proto.defaultState = function defaultState() {
        var _this$props = this.props,
          defaultStyles = _this$props.defaultStyles,
          styles = _this$props.styles,
          willEnter = _this$props.willEnter,
          willLeave = _this$props.willLeave,
          didLeave = _this$props.didLeave;
        var destStyles =
          typeof styles === 'function' ? styles(defaultStyles) : styles; // this is special. for the first time around, we don't have a comparison
        // between last (no last) and current merged props. we'll compute last so:
        // say default is {a, b} and styles (dest style) is {b, c}, we'll
        // fabricate last as {a, b}

        var oldMergedPropsStyles;

        if (defaultStyles == null) {
          oldMergedPropsStyles = destStyles;
        } else {
          oldMergedPropsStyles = defaultStyles.map(function(defaultStyleCell) {
            // TODO: key search code
            for (var i = 0; i < destStyles.length; i++) {
              if (destStyles[i].key === defaultStyleCell.key) {
                return destStyles[i];
              }
            }

            return defaultStyleCell;
          });
        }

        var oldCurrentStyles =
          defaultStyles == null
            ? destStyles.map(function(s) {
                return stripStyle(s.style);
              })
            : defaultStyles.map(function(s) {
                return stripStyle(s.style);
              });
        var oldCurrentVelocities =
          defaultStyles == null
            ? destStyles.map(function(s) {
                return mapToZero(s.style);
              })
            : defaultStyles.map(function(s) {
                return mapToZero(s.style);
              });

        var _mergeAndSync3 = mergeAndSync(
            // Because this is an old-style createReactClass component, Flow doesn't
            // understand that the willEnter and willLeave props have default values
            // and will always be present.
            willEnter,
            willLeave,
            didLeave,
            oldMergedPropsStyles,
            destStyles,
            oldCurrentStyles,
            oldCurrentVelocities,
            oldCurrentStyles, // oldLastIdealStyles really
            oldCurrentVelocities, // oldLastIdealVelocities really
          ),
          mergedPropsStyles = _mergeAndSync3[0],
          currentStyles = _mergeAndSync3[1],
          currentVelocities = _mergeAndSync3[2],
          lastIdealStyles = _mergeAndSync3[3],
          lastIdealVelocities = _mergeAndSync3[4];

        return {
          currentStyles: currentStyles,
          currentVelocities: currentVelocities,
          lastIdealStyles: lastIdealStyles,
          lastIdealVelocities: lastIdealVelocities,
          mergedPropsStyles: mergedPropsStyles,
        };
      }; // after checking for unreadPropStyles != null, we manually go set the
      // non-interpolating values (those that are a number, without a spring
      // config)

      _proto.componentDidMount = function componentDidMount() {
        this.prevTime = performanceNow();
        this.startAnimationIfNecessary();
      };

      _proto.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(
        props,
      ) {
        if (this.unreadPropStyles) {
          // previous props haven't had the chance to be set yet; set them here
          this.clearUnreadPropStyle(this.unreadPropStyles);
        }

        var styles = props.styles;

        if (typeof styles === 'function') {
          this.unreadPropStyles = styles(
            rehydrateStyles(
              this.state.mergedPropsStyles,
              this.unreadPropStyles,
              this.state.lastIdealStyles,
            ),
          );
        } else {
          this.unreadPropStyles = styles;
        }

        if (this.animationID == null) {
          this.prevTime = performanceNow();
          this.startAnimationIfNecessary();
        }
      };

      _proto.componentWillUnmount = function componentWillUnmount() {
        this.unmounting = true;

        if (this.animationID != null) {
          raf_1.cancel(this.animationID);
          this.animationID = null;
        }
      };

      _proto.render = function render() {
        var hydratedStyles = rehydrateStyles(
          this.state.mergedPropsStyles,
          this.unreadPropStyles,
          this.state.currentStyles,
        );
        var renderedChildren = this.props.children(hydratedStyles);
        return renderedChildren && React.Children.only(renderedChildren);
      };

      return TransitionMotion;
    })(React.Component);

  TransitionMotion.defaultProps = {
    willEnter: function willEnter(styleThatEntered) {
      return stripStyle(styleThatEntered.style);
    },
    // recall: returning null makes the current unmounting TransitionStyle
    // disappear immediately
    willLeave: function willLeave() {
      return null;
    },
    didLeave: function didLeave() {},
  };
  TransitionMotion.propTypes = {
    defaultStyles: propTypes.arrayOf(
      propTypes.shape({
        key: propTypes.string.isRequired,
        data: propTypes.any,
        style: propTypes.objectOf(propTypes.number).isRequired,
      }),
    ),
    styles: propTypes.oneOfType([
      propTypes.func,
      propTypes.arrayOf(
        propTypes.shape({
          key: propTypes.string.isRequired,
          data: propTypes.any,
          style: propTypes.objectOf(
            propTypes.oneOfType([propTypes.number, propTypes.object]),
          ).isRequired,
        }),
      ),
    ]).isRequired,
    children: propTypes.func.isRequired,
    willEnter: propTypes.func,
    willLeave: propTypes.func,
    didLeave: propTypes.func,
  };

  var presets = {
    noWobble: {
      stiffness: 170,
      damping: 26,
    },
    // the default, if nothing provided
    gentle: {
      stiffness: 120,
      damping: 14,
    },
    wobbly: {
      stiffness: 180,
      damping: 12,
    },
    stiff: {
      stiffness: 210,
      damping: 20,
    },
  };

  var defaultConfig = _extends({}, presets.noWobble, {
    precision: 0.01,
  });

  function spring(val, config) {
    return _extends({}, defaultConfig, {}, config, {
      val: val,
    });
  }

  var hasWarned = false;
  function reorderKeys() {
    {
      if (!hasWarned) {
        hasWarned = true;
        console.error(
          "`reorderKeys` has been removed, since it is no longer needed for TransitionMotion's new styles array API.",
        );
      }
    }
  }

  exports.Motion = Motion;
  exports.StaggeredMotion = StaggeredMotion;
  exports.TransitionMotion = TransitionMotion;
  exports.spring = spring;
  exports.presets = presets;
  exports.stripStyle = stripStyle;
  exports.reorderKeys = reorderKeys;

  Object.defineProperty(exports, '__esModule', { value: true });
});
